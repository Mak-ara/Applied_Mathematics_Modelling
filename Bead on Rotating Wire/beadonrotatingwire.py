# -*- coding: utf-8 -*-
"""BeadonRotatingWire.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XH6ydrVhizoXrj__OA6Lg4wFV8fW635m
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from scipy.integrate import odeint

# Physical parameters
m = 1.0      # mass of bead (kg)
g = 9.81     # gravity (m/s²)
omega = 2.0  # angular velocity (rad/s)
k = 0.5      # wire shape parameter (parabolic: z = k*r²)

def wire_shape(r):
    """Wire shape: z = k*r² (parabolic)"""
    return k * r**2

def wire_derivative(r):
    """First derivative: dz/dr = 2*k*r"""
    return 2 * k * r

def wire_second_derivative(r):
    """Second derivative: d²z/dr² = 2*k"""
    return 2 * k

def equations_of_motion(y, t):
    """
    Governing equation: m[1 + (f'(r))²]r̈ + mf'(r)f''(r)ṙ² - mrω² - mgf'(r) = 0
    Converted to system of first-order ODEs:
    y[0] = r, y[1] = dr/dt
    """
    r, r_dot = y

    # Avoid singularity at r=0
    r = max(r, 0.01)

    # Wire derivatives
    f_prime = wire_derivative(r)
    f_double_prime = wire_second_derivative(r)

    # Equation of motion solved for r̈
    numerator = m*r*omega**2 + m*g*f_prime - m*f_prime*f_double_prime*r_dot**2
    denominator = m*(1 + f_prime**2)

    r_ddot = numerator / denominator

    return [r_dot, r_ddot]

# Initial conditions
r0 = 0.5      # initial radial position (m)
r_dot0 = 0.0  # initial radial velocity (m/s)
y0 = [r0, r_dot0]

# Time parameters
t_max = 10.0
dt = 0.01
t = np.arange(0, t_max, dt)

# Solve the differential equation
solution = odeint(equations_of_motion, y0, t)
r_solution = solution[:, 0]
r_dot_solution = solution[:, 1]

# Calculate corresponding z positions
z_solution = wire_shape(r_solution)

# Calculate theta positions (rotation)
theta_solution = omega * t

# Convert to Cartesian coordinates for visualization
x_solution = r_solution * np.cos(theta_solution)
y_cartesian_solution = r_solution * np.sin(theta_solution)

print(f"Simulation Results:")
print(f"Max radial position: {np.max(r_solution):.3f} m")
print(f"Min radial position: {np.min(r_solution):.3f} m")
print(f"Final radial position: {r_solution[-1]:.3f} m")

# Create animation
fig = plt.figure(figsize=(12, 8))

# 3D plot
ax1 = fig.add_subplot(221, projection='3d')
ax1.set_title('3D View: Bead on Rotating Wire')
ax1.set_xlabel('X (m)')
ax1.set_ylabel('Y (m)')
ax1.set_zlabel('Z (m)')

# Top view
ax2 = fig.add_subplot(222)
ax2.set_title('Top View (X-Y plane)')
ax2.set_xlabel('X (m)')
ax2.set_ylabel('Y (m)')
ax2.set_aspect('equal')

# Side view
ax3 = fig.add_subplot(223)
ax3.set_title('Side View (R-Z plane)')
ax3.set_xlabel('R (m)')
ax3.set_ylabel('Z (m)')

# Time series
ax4 = fig.add_subplot(224)
ax4.set_title('Radial Position vs Time')
ax4.set_xlabel('Time (s)')
ax4.set_ylabel('R (m)')

def animate(frame):
    # Clear all axes
    ax1.clear()
    ax2.clear()
    ax3.clear()
    ax4.clear()

    # Current time index
    idx = min(frame * 5, len(t) - 1)  # Slow down animation
    current_time = t[idx]

    # 3D plot
    ax1.set_title(f'3D View: t = {current_time:.2f}s')
    ax1.set_xlabel('X (m)')
    ax1.set_ylabel('Y (m)')
    ax1.set_zlabel('Z (m)')

    # Draw wire (full rotation)
    r_wire = np.linspace(0.1, 2.0, 100)
    z_wire = wire_shape(r_wire)
    theta_wire = np.linspace(0, 2*np.pi, 50)

    for i in range(0, len(theta_wire), 5):  # Draw wire segments
        x_wire = r_wire * np.cos(theta_wire[i])
        y_wire = r_wire * np.sin(theta_wire[i])
        ax1.plot(x_wire, y_wire, z_wire, 'b-', alpha=0.3, linewidth=1)

    # Draw bead trajectory up to current time
    ax1.plot(x_solution[:idx+1], y_cartesian_solution[:idx+1], z_solution[:idx+1],
             'r-', linewidth=2, label='Bead trajectory')

    # Draw current bead position
    ax1.scatter([x_solution[idx]], [y_cartesian_solution[idx]], [z_solution[idx]],
               c='red', s=100, label='Bead')

    ax1.set_xlim([-2, 2])
    ax1.set_ylim([-2, 2])
    ax1.set_zlim([0, 2])
    ax1.legend()

    # Top view
    ax2.set_title(f'Top View: t = {current_time:.2f}s')
    ax2.plot(x_solution[:idx+1], y_cartesian_solution[:idx+1], 'r-', linewidth=2)
    ax2.scatter([x_solution[idx]], [y_cartesian_solution[idx]], c='red', s=100)

    # Draw rotating wire outline
    theta_circle = np.linspace(0, 2*np.pi, 100)
    for r_circle in [0.5, 1.0, 1.5]:
        x_circle = r_circle * np.cos(theta_circle)
        y_circle = r_circle * np.sin(theta_circle)
        ax2.plot(x_circle, y_circle, 'b--', alpha=0.3)

    ax2.set_xlim([-2, 2])
    ax2.set_ylim([-2, 2])
    ax2.set_aspect('equal')
    ax2.grid(True)

    # Side view (R-Z)
    ax3.set_title('Wire Shape & Bead Motion')
    r_wire_side = np.linspace(0, 2, 100)
    z_wire_side = wire_shape(r_wire_side)
    ax3.plot(r_wire_side, z_wire_side, 'b-', linewidth=2, label='Wire shape')
    ax3.plot(r_solution[:idx+1], z_solution[:idx+1], 'r-', linewidth=2, label='Bead path')
    ax3.scatter([r_solution[idx]], [z_solution[idx]], c='red', s=100)
    ax3.set_xlim([0, 2])
    ax3.set_ylim([0, 2])
    ax3.grid(True)
    ax3.legend()

    # Time series
    ax4.set_title('Radial Position vs Time')
    ax4.plot(t[:idx+1], r_solution[:idx+1], 'r-', linewidth=2)
    ax4.scatter([current_time], [r_solution[idx]], c='red', s=100)
    ax4.axhline(y=np.sqrt(g/(omega**2 * 2*k)), color='g', linestyle='--',
                alpha=0.7, label=f'Equilibrium: r = {np.sqrt(g/(omega**2 * 2*k)):.3f}m')
    ax4.set_xlim([0, t_max])
    ax4.set_ylim([0, 2])
    ax4.grid(True)
    ax4.legend()

    plt.tight_layout()

# Create and run animation
frames = len(t) // 5  # Reduce frames for performance
anim = animation.FuncAnimation(fig, animate, frames=frames, interval=50, repeat=True)

# Display static plots first
animate(len(t)//10)  # Show a frame in the middle
plt.tight_layout()
plt.show()

# Print equilibrium analysis
equilibrium_r = np.sqrt(g / (omega**2 * 2*k)) if omega > 0 else float('inf')
print(f"\nPhysical Analysis:")
print(f"Wire shape: z = {k}r² (parabolic)")
print(f"Angular velocity: {omega} rad/s")
print(f"Theoretical equilibrium radius: {equilibrium_r:.3f} m")
print(f"Equilibrium height: {wire_shape(equilibrium_r):.3f} m")

# Save animation (optional - uncomment to save)
# print("Saving animation...")
# anim.save('bead_rotating_wire.mp4', writer='ffmpeg', fps=20)
# print("Animation saved as 'bead_rotating_wire.mp4'")